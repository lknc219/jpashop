
컬렉션 조회 최적화

====================================================================================================================================

V1 엔티티를 직접 조회
hibernate5module을 빈으로 증록해주고 Order와 연관관계가 있는 엔티티 필드마다  jsonignore 애너테이션을 선언해준다.
각 엔티티의 필드들을 get 해줌으로써 강제로 초기화를 해주고 해당 값을 리턴해주는 방법.
모든 엔티티의 필요하지 않은 정보들도 모두 반환되기 때문에 이렇게 Entity를 직접 반환하지않고 DTO를 만들어서 반환하는것이 옳다.

    @GetMapping("/api/v1/orders")
    public List<Order> orderV1() {
        List<Order> all = orderRepository.findAllByString(new OrderSearch());

        for (Order order : all) {
            order.getMember().getName();
            order.getDelivery().getAddress();

            List<OrderItem> orderItems = order.getOrderItems();
//            for (OrderItem orderItem : orderItems) {
//                orderItem.getItem().getName();
//            }
            orderItems.stream().forEach(o -> o.getItem().getName());
        }
        return all;
    }
    
====================================================================================================================================

V2 엔티티를 DTO로 반환

이전 예제들과 마찬가지로 엔티티를 DTO로 변환해서 뿌려준다.
하지만 첫번째 엔티티껍데기 뿐만 아니라 엔티티속에 있는 엔티티도 모두 dto로 변환해주어야 한다.
Order의 Orderitem 의 정보들도 모두 dto로 변환 후 출력해줘야함.

이 방법의 경우 영속성 컨텍스트에 올라가지 않은 데이터를 조회할 때마다 쿼리를 호출해서 성능문제가 많다.

    @GetMapping("/api/v2/orders")
    public List<OrderDto> ordersV2() {
        List<Order> orders = orderRepository.findAllByString(new OrderSearch());
        List<OrderDto> collect = orders.stream()
                .map(o -> new OrderDto(o))
                .collect(Collectors.toList());
        return collect;
    }

    @Data
    static class OrderDto {

        private Long orderId;
        private String name;
        private LocalDateTime localDateTime;
        private OrderStatus orderStatus;
        private Address address;
        private List<OrderItemDto> orderItems;

        public OrderDto(Order order) {
            orderId = order.getId();
            name = order.getMember().getName();
            localDateTime = order.getOrderDate();
            orderStatus = order.getStatus();
            address = order.getDelivery().getAddress();
            orderItems = order.getOrderItems().stream()
                    .map(orderItem -> new OrderItemDto(orderItem))
                    .collect(Collectors.toList());
        }
    }

    @Data
    static class OrderItemDto {

        private String itemName;
        private int orderPrice;
        private int count;

        public OrderItemDto(OrderItem orderItem) {

            itemName = orderItem.getItem().getName();
            orderPrice = orderItem.getOrderPrice();
            count = orderItem.getCount();
        }
    }

====================================================================================================================================

V3 페치조인으로 데이터 호출하기

페치조인으로 불러오면 컬렉션의 일대다 데이터는 뻥튀기 되어온다.
그래서 select 앞에 distinct 를 붙여주어 데이터베이스상에서도 distinct를 사용하고 
뻥튀기 되어온 데이터중 아이디값으로 애플리케이션에서 또 한번 중복을 제거해주기때문에 원하는 데이터의 갯수만큼 가져올 수 있다.
하지만 컬렉션에서 페치조인은 페이징이 불가능하다.
데이터를 모두 가져 온 후 애플리케이션 메모리에서 페이징을 하게 되는데 이는 큰 과부하를 일으킬 수 있기때문에 사용 x
중복제거를 DB상에서 하는것이 아니고 애플리케이션에서 하기때문에 일단 모두 가져와야한다.

    @GetMapping("/api/v3/orders")
    public List<OrderDto> ordersV3() {
        List<Order> orders = orderRepository.findAllWithItem();
        List<OrderDto> result = orders.stream()
                .map(o -> new OrderDto(o))
                .collect(Collectors.toList());
        return result;
    }

    public List<Order> findAllWithItem() {
        return em.createQuery(
                "select distinct o from Order o"+
                        " join fetch o.member m" +
                        " join fetch o.delivery d" +
                        " join fetch o.orderItems oi" +
                        " join fetch oi.item i", Order.class)
                .getResultList();
    }
    



====================================================================================================================================

V3.1 페이징과 한계돌파
컬렉션을 페이징할 수 없다 (일대다이기떄문)
우리는 order를 기준으로 한 데이터 갯수를 받고 싶지만
DB입장에서는 items의 데이터가 많기때문에 조인 하는 순간 데이터의 갯수가 items를 기준으로 맞춰진다.
이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도하는데 이는 장애로 이어질 수 있다.

페이징 + 컬렉션 엔티티 조회

ToOne 관계는 모두 페치조인 한다.(ToOne 관계는 데이터를 증가시키지 않으므로 페이징 쿼리에 영향 X)
컬렉션은 지연로딩으로 조회한다.
지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size, @BatchSize를 적용한다.
	yml 설정파일에 hibernate.default_batch_fetch_size :100 글로벌 설정
	@BatchSize: 100 개별 최적화
	이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다.
	
findAllWithMemberDelivery(int offset, int limit)


페치조인과 비교해서 쿼리 호출 수가 약간 증가하지만 DB 전송량이 감소하고, 
컬렉션 페치 조인은 페이징이 불가능하지만 이 방법으로는 페이징이 가능하다.
ToOne 관계는 페치조인으로, 나머지는 hibernate.default_batch_fetch_size 로 최적화 하자
	

====================================================================================================================================

V4 : JPA에서 DTO 직접 조회

	*) repository 에서 일반 repository와 query디렉터리로 나누는 것은
	일반 핵심 비즈니르 로직과, api등 화면과 관련된 기능에 의존적인 로직을 나누기 위해서 이다.

@GetMapping("/api/v4/orders")

Query 루트 1번, 컬렉션 N번 실행
ToOne (N:1, 1:1) 관계들을 먼저 조회하고, ToMany(1:N) 관계는 각각 별도로 처리한다.
	이유 : ToOne 관계는 조인해도 데이터 row 수가 증가하지 않는다
			  To Many(1:N) 관계는 조인하면 row수가 증가한다.
row 수가 증가하지 않는 ToOne 관계는 조인으로 최적화 하기 쉬우므로 한번에 조회하고, ToMany 관계는 최적화가 어려우므로 findOrderItems()같은 별토의 메서드로 조회한다.

====================================================================================================================================

