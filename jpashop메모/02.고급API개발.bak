고급 API

API를 만들기 전 샘플 데이터를 먼저 생성한다
	 userA
	 	JPA1 BOOK
	 	JPA2 BOOK
	 	
	 userB
	 	SPRING1 BOOK
	 	SPRING1 BOOK
	 	
====================================================================================================================================

엔티티를 직접 노출하면 안되기 때문에 이런게 있다는 것만 알면 된다.

엔티티 직접 노출 시 (V1)

Order 엔티티는 Member와 Delivery 와 연관되어있다.

Order의 전체 목록을 조회하는 OrderRepository.findAllByString(new OrderSearch()); 를 실행하면
연관되어있는 엔티티에서 또 연관되어있는 엔티티를 찾아 무한루프를 돌게 된다.
이를 @JsonIgnore 애너테이션으로 한쪽을 막아주는 방법으로 해결해 보려 해도 에러가 난다.
간단한 해결법으로는 hibernate5Module을 스프링 빈으로 등록하면된다.

	@Bean
	Hibernate5Module hibernate5Module() {
		return new Hibernate5Module();
	}

이렇게 하면 조회된 것들 중 LAZYLOADING인 것들은 null로 조회가 된다.

hibernate5module 의 설정을 변경해서 값이 나오게 할 수 있다.


====================================================================================================================================

SimpleOrderDto 만든 후 조회

    @GetMapping("/api/v2/simple-orders")
    public List<SimpleOrderDto> ordersV2() {
        List<Order> orders = orderRepository.findAllByString(new OrderSearch());

        List<SimpleOrderDto> result = orders.stream()
                .map(o -> new SimpleOrderDto(o))
                .collect(Collectors.toList());

        return result;
    }

    @Data
    static class SimpleOrderDto {

        private Long orderId;
        private String name;
        private LocalDateTime orderDate;
        private OrderStatus orderStatus;
        private Address address;

        public SimpleOrderDto(Order order) {
            orderId = order.getId();
            name = order.getMember().getName();
            orderDate = order.getOrderDate();
            orderStatus = order.getStatus();
            address = order.getDelivery().getAddress();
        }
    }

하지만 이렇게 dto로 만들어서 조회 할 때도 N+1의 문제는 해결하지 못한다
해당 코드에선 order 조회쿼리1 member2, delivery2  = 총 5개의 쿼리가 나가게 된다.
====================================================================================================================================

